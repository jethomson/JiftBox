
<!DOCTYPE html>
<html lang="en" class="">

<head>
<meta charset='utf-8'>
	<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
	<title>Upload Overlay</title>
	<style>
	body {
		color: #eaeaea;
		text-align: center;
		font-family: verdana, sans-serif;
		background: #000000;
		/*zoom: 2;
		-moz-transform: scale(2);
		-moz-transform-origin: 0 0;*/
	}
	canvas{
		background-color: #002400;
		display: none;
		/*image-rendering: pixelated;*/
	}
	div {
		text-align: center;
		padding: 5px;
		font-size: 1rem;
	}
	div[name="display_border"] {
		border:1px solid white;
		margin:0 auto;
	}
	
	p {
		margin: 0.5rem 0;
	}
	
	image {
		display: inline-block;
		margin: auto;
		vertical-align: middle;
	}
	button {
		margin: 5px;
	}
	button,
	input[type="button"] {
		border: 0;
		border-radius: 0.3rem;
		background: #1fa3ec;
		color: #faffff;
		line-height: 2.4rem;
		font-size: 1.2rem;
		width: 100%;
		-webkit-transition-duration: 0.4s;
		transition-duration: 0.4s;
		cursor: pointer;
	}
	button:hover,
	input[type="button"]:hover {
		background: #0e70a4;
	}
	input[name="emoji"] { width: auto; display: inline; background:none; border:none; }
	input[id="input_text"] {
		display: block;
		text-align: center;
		margin: 0 auto;
	}

	/* HIDE RADIO */
	[type=radio] { 
		position: absolute;
		opacity: 0;
		width: 0;
		height: 0;
	}

	/* IMAGE STYLES */
	[type=radio] + img {
		cursor: pointer;
	}

	/* CHECKED STYLES */
	[type=radio]:checked + img {
		outline: 2px solid #f00;
	}
	
	</style>
</head>
<body>



	<div style="display:inline-block; min-width:340px;">
		<div>
		<form method='POST' onsubmit="event.preventDefault(); upload()">
			<div>Enter character(s):</div>
			<input type="text" id="input_text" maxlength=2 required>
			<input type="button" name="emoji" value="ðŸ™‚">
			<input type="button" name="emoji" value="ðŸ¤£">
			<input type="button" name="emoji" value="ðŸ¤ª">
			<input type="button" name="emoji" value="ðŸ¤“">
			<input type="button" name="emoji" value="ðŸ˜Ž">
			<input type="button" name="emoji" value="ðŸ¥³">
			<br>
			<input type="button" name="emoji" value="ðŸ¦”">
			<input type="button" name="emoji" value="ðŸ•">
			<input type="button" name="emoji" value="ðŸˆ">
			<input type="button" name="emoji" value="ðŸ’">
			<input type="button" name="emoji" value="ðŸ˜">
			<input type="button" name="emoji" value="ðŸŒ»">
			<br>
			<input type="button" name="emoji" value="ðŸ•">
			<input type="button" name="emoji" value="ðŸŸ">
			<input type="button" name="emoji" value="ðŸŽ‚">
			<input type="button" name="emoji" value="ðŸŒˆ">
			<input type="button" name="emoji" value="ðŸ«€">
			<input type="button" name="emoji" value="ðŸ‘">
			<br>
			<input type="button" name="emoji" value="ðŸŽ…">
			<input type="button" name="emoji" value="â„ï¸">
			<input type="button" name="emoji" value="ðŸŽ„">
			<input type="button" name="emoji" value="â›„">
			<input type="button" name="emoji" value="ðŸŽ">
			<input type="button" name="emoji" value="â­">
			<br>
			<input type="button" name="emoji" value="ðŸ‘½">
			<input type="button" name="emoji" value="ðŸ’€">
			<input type="button" name="emoji" value="ðŸŽƒ">
			<input type="button" name="emoji" value="ðŸ‘»">
			<input type="button" name="emoji" value="ðŸ§Ÿ">
			<input type="button" name="emoji" value="ðŸ§ ">
			<br>
			<input type="button" name="emoji" value="ðŸ’©">
			<input type="button" name="emoji" value="ðŸ¤–">
			<input type="button" name="emoji" value="ðŸš€">
			<input type="button" name="emoji" value="ðŸ›¸">
			<input type="button" name="emoji" value="â˜¢ï¸">
			<input type="button" name="emoji" value="ðŸ’£">
			<canvas id="canvas"></canvas>
			<br>
			<div>White border represents size of display. Dark green background represents transparency. Pick an overlay size:</div>
			<div name="display_border">
			<label>
				<input type="radio" name="size" id="radio_small">
				<img id="image_small">
			</label>
			</div>
			<br>
			<div name="display_border">
			<label>
				<input type="radio" name="size" id="radio_medium" checked>
				<img id="image_medium">
			</label>
			</div>
			<br>
			<div name="display_border">
			<label>
				<input type="radio" name="size" id="radio_large">
				<img id="image_large">
			</label>
			</div>
			<br>
			<!--LittleFS implementation for the ESP8266 supports filenames of up to 31 characters + terminating zero. 31 - 4 (.bmp) = 27 -->
			<div style="display:flex;justify-content:center;align-items:center;">
				<label>Filename: </label><input type="text" id="filename" maxlength="27" placeholder="Enter unique filename to save overlay image as." style="width: 100%" required><label>.bmp</label>
			</div>
			<button type="submit">Upload</button>
		</form>
		<a href="/"><button name="">Main Menu</button></a>
		</div>
	</div>


	<script>
	
	
/*! canvas-to-bmp version 1.0 ALPHA
    (c) 2015 Ken "Epistemex" Fyrstenberg
    MIT License (this header required)
*/

var CanvasToBMP = {

  /**
   * Convert a canvas element to ArrayBuffer containing a BMP file
   * with support for 32-bit (alpha).
   *
   * Note that CORS requirement must be fulfilled.
   *
   * @param {HTMLCanvasElement} canvas - the canvas element to convert
   * @return {ArrayBuffer}
   */
  toArrayBuffer: function(canvas, channels = 3) {

    var bpp = (channels == 4) ? 32 : 24,             // bits per pixel
        w = canvas.width,
        h = canvas.height,
        wc = w * channels,                           // width * channels
        idata = canvas.getContext("2d").getImageData(0, 0, w, h),
        data32 = new Uint32Array(idata.data.buffer), // 32-bit representation of canvas

        stride = Math.floor((bpp * w + 31) / 32) * 4, // row length incl. padding
        pixelArraySize = stride * h,                 // total bitmap size
        fileLength = 122 + pixelArraySize,           // header size is known + bitmap

        file = new ArrayBuffer(fileLength),          // raw byte buffer (returned)
        view = new DataView(file),                   // handle endian, reg. width etc.
        pos = 0, x, y = 0, p, s = 0, a, v;


    // write file header
    setU16(0x4d42);          // BM
    setU32(fileLength);      // total length
    pos += 4;                // skip unused fields
    setU32(0x7a);            // offset to pixels

    // DIB header
    setU32(108);             // header size
    setU32(w);

    setU32(-h >>> 0);        // negative = top-to-bottom
    //if (channels == 4) setU32(-h >>> 0);        // negative = top-to-bottom
    //else setU32(h);

    setU16(1);               // 1 plane
    setU16(bpp);             // bits per pixel

    if (channels == 4) setU32(3); // no compression (BI_BITFIELDS, 3)
    else setU32(0);               // no compression (BI_RGB, 0)

    setU32(pixelArraySize);  // bitmap size incl. padding (stride x height)   // what units is this in??? OK to set to 0 if no compression
    setU32(2835);            // pixels/meter h (~72 DPI x 39.3701 inch/m)
    setU32(2835);            // pixels/meter v
    pos += 8;                // skip color/important colors
    setU32(0xff0000);        // red channel mask
    setU32(0xff00);          // green channel mask
    setU32(0xff);            // blue channel mask

    if (channels == 4) setU32(0xff000000); // alpha channel mask
    else setU32(0x00000000);               // no alpha channel mask

    setU32(0x57696e20); // "win" color space
    //setU32(0x73524742); // ??? gimp color space

    // bitmap data, change order of ABGR to BGRA
    while (y < h) {
      p = 0x7a + y * stride; // offset + stride x height
      x = 0;
      while (x < wc) {
        v = data32[s++];                       // get ABGR
        a = v >>> 24;                          // alpha channel
        b = v >>> 16 & 0xFF;                   //blue channel
        g = v >>>  8 & 0xFF;                   //green channel
        r = v & 0xFF;                          //red channel
        view.setUint8(p + x, b);
        x++;
        view.setUint8(p + x, g);
        x++;
        view.setUint8(p + x, r);
        x++;
        if (channels == 4) {
          view.setUint8(p + x, a);
          x++;
        }
      }
      y++;
    }


    return file;

    // helper method to move current buffer position
    function setU16(data) {view.setUint16(pos, data, true); pos += 2}
    function setU32(data) {view.setUint32(pos, data, true); pos += 4}
  },

  /**
   * Converts a canvas to BMP file, returns a Blob representing the
   * file. This can be used with URL.createObjectURL().
   * Note that CORS requirement must be fulfilled.
   *
   * @param {HTMLCanvasElement} canvas - the canvas element to convert
   * @return {Blob}
   */
  toBlob: function(canvas, channels = 3) {
    return new Blob([this.toArrayBuffer(canvas, channels)], {
      type: "image/bmp"
    });
  },

  /**
   * Converts the canvas to a data-URI representing a BMP file.
   * Note that CORS requirement must be fulfilled.
   *
   * @param canvas
   * @return {string}
   */
  toDataURL: function(canvas, channels = 3) {
    var buffer = new Uint8Array(this.toArrayBuffer(canvas, channels)),
        bs = "", i = 0, l = buffer.length;
    while (i < l) bs += String.fromCharCode(buffer[i++]);
    return "data:image/bmp;base64," + btoa(bs);
  }
};

	
	
	base_url = '';
	if (window.location.protocol == "file:") {
		// makes for easier debugging.
		// if html is loaded locally, can see the results of editing more easily.
		// otherwise every change to html would require uploading new version to microcontroller.
		base_url = "http://jiftbox.local";
	}

	//const params = new Proxy(new URLSearchParams(window.location.search), {
	//	get: (searchParams, prop) => searchParams.get(prop),
	//});
	//const display_width = params.display_width;
	//const display_height = params.display_height;
	

	// set defaults but allow for webserver to replace templates
	// if you do not see the templates MY_WIDTH and MY_HEIGHT it is because
	// they were replaced with numbers
	let display_width = 240;  // default
	let display_height = 135; // default
	if (typeof $MY_WIDTH$ !== "undefined" && typeof $MY_HEIGHT$ !== "undefined") {
		display_width = $MY_WIDTH$;   // template substitution
		display_height = $MY_HEIGHT$; // template substitution
	}
	
	const mdim = Math.max(display_width, display_height);

	//const cwidth = Math.round(0.5*mdim);
	const cwidth = Math.round(0.25*mdim);
	const cheight = cwidth;
	
	const font_family = "Arial";
	const font_size = Math.round(0.80*cwidth) + "px";
	
	const factor_small = 0.50;
	const factor_medium = 0.75;
	const factor_large = 1.00;

	let ctx = document.getElementById('canvas').getContext('2d');
	let input = document.getElementById('input_text');
	
	let radio_small = document.getElementById('radio_small');
	let radio_medium = document.getElementById('radio_medium');
	let radio_large = document.getElementById('radio_large');
	let image_small = document.getElementById('image_small');
	let image_medium = document.getElementById('image_medium');
	let image_large = document.getElementById('image_large');

	const nodeList = document.querySelectorAll('[name="display_border"]');
	for (let i = 0; i < nodeList.length; i++) {
		nodeList[i].style.width = display_width + "px";
		nodeList[i].style.height = display_height + "px";
	}

	input.style.width = display_width + "px";
	input.style.fontFamily = font_family;
	input.style.fontSize = font_size;
	
	radio_small.value = factor_small;
	radio_medium.value = factor_medium;
	radio_large.value = factor_large;

	image_small.style.width = factor_small*cwidth + 'px';
	image_small.style.height = factor_small*cheight + 'px';
	image_medium.style.width = factor_medium*cwidth + 'px';
	image_medium.style.height = factor_medium*cheight + 'px';
	image_large.style.width = factor_large*cwidth + 'px';
	image_large.style.height = factor_large*cheight + 'px';


	function createHiPPICanvas(width, height) {
		const ratio = window.devicePixelRatio;
		const canvas = document.getElementById('canvas');

		canvas.width = width * ratio;
		canvas.height = height * ratio;
		canvas.style.width = width + "px";
		canvas.style.height = height + "px";
		canvas.getContext("2d").scale(ratio, ratio);
	}

	function convert(text) {
		document.getElementById('input_text').value = text;

		ctx.font = font_size +" "+ font_family;
		ctx.fillStyle = "#002400"; // transparent background
		ctx.fillRect(0, 0, cwidth, cheight);

		ctx.textAlign = 'center';
		ctx.textBaseline = 'middle';
		ctx.fillStyle = "#FFFFFF"; // font color
		ctx.fillText(text, cwidth/2, cheight/2);

		console.log(text);
		
		//ctx.fillStyle = "#880203";
		//ctx.fillRect(0, 0, cwidth, cheight);

		image_small.src = ctx.canvas.toDataURL('image/bmp');
		image_medium.src = ctx.canvas.toDataURL('image/bmp');
		console.log(image_medium.src);
		image_large.src = ctx.canvas.toDataURL('image/bmp');
	}

	function upload() {
		const ratio = window.devicePixelRatio;
		const original_canvas = document.getElementById('canvas');
		
		let factor = document.querySelector('[type=radio]:checked').value;

		let new_canvas = document.createElement('canvas');
		//let new_canvas = document.getElementById("canvas_tmp");
		let context = new_canvas.getContext('2d');

		new_canvas.width = factor * original_canvas.width;
		new_canvas.height = factor * original_canvas.height;
		
		new_canvas.style.width = (factor * original_canvas.width) + 'px';
		new_canvas.style.height = (factor * original_canvas.height) + 'px';
		
		new_canvas.getContext("2d").scale(factor * ratio, factor * ratio);

		context.drawImage(original_canvas, 0, 0);


		let blob = CanvasToBMP.toBlob(new_canvas, 3);
		const filename = '/overlays/' + document.getElementById('filename').value + '.bmp';
		let data = new FormData();
		data.append("upload", blob, filename);
		fetch(base_url+'/file_upload', {method:"POST", body:data})
			.then(response => response.text())
			.then(data => console.log(data));


/*
		new_canvas.toBlob((blob) => {
			const filename = '/overlays/' + document.getElementById('filename').value + '.bmp';
			let data = new FormData();
			data.append("upload", blob, filename);
			fetch(base_url+'/file_upload', {method:"POST", body:data})
				.then(response => response.text())
				.then(data => console.log(data));
		}, 'image/bmp');
*/
	}


	createHiPPICanvas(cwidth, cheight);
	input.addEventListener('input', function(){convert(this.value)}, false);
	
	const emojiList = document.querySelectorAll('[name="emoji"]');
	for (let i = 0; i < emojiList.length; i++) {
		emojiList[i].addEventListener('click', function(){convert(this.value)}, false);
	}

	var event = new Event('input');
	input.dispatchEvent(event);

	</script>

</body>
</html>
